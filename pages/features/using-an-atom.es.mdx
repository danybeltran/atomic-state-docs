# Usando un atom

Ahora podemos usar el Ã¡tomo `clicks` en cualquier componente. Para hacer eso, debes usar el hook `useAtom`.

Esto es similar a `useState`, la principal diferencia es que devuelve 3 elementos en lugar de 2. El tercer elemento es el objeto de acciones.

Pero lo veremos mÃ¡s tarde :)

```jsx
import { useAtom } from 'atomic-state'
import { clicks } from 'atoms'

function App() {
  const [clicksCount, setClicksCount] = useAtom(clicks)
  return (
    <div>
      <h2>{clicksCount}</h2>
      <button
        onClick={() => {
          setClicksCount((c) => c + 1)
        }}
      >
        Increase
      </button>
    </div>
  )
}
```

Â¡Acabas de crear tu primer Ã¡tomo ðŸ¥³!

## Suscribirse a un Ã¡tomo

Cuando usa `useAtom`, ese componente o hook personalizado se suscribirÃ¡ a todos los cambios realizados en ese Ã¡tomo.
That means, it will trigger a re-render of that component's React tree.

Ahora, dividamos ese componente en dos.

En un componente, mostraremos el valor de "clicks", y en el otro, lo actualizaremos.

```jsx
import { useAtom } from 'atomic-state'
import { clicks } from 'atoms'

// Show the value
function ClicksDisplay() {
  const [clicksCount] = useAtom(clicks)
  return <h2>{clicksCount}</h2>
}

// We will update `clicks` here
function ClicksUpdate() {
  // Ommit `clicks`'s value, we don't need it
  const [, setClicksCount] = useAtom(clicks)
  return (
    <button
      onClick={() => {
        setClicksCount((c) => c + 1)
      }}
    >
      Increase
    </button>
  )
}

export default function App() {
  return (
    <div>
      <ClicksDisplay />
      <ClicksUpdate />
    </div>
  )
}
```

Â¡Eso es todo!

BÃ¡sicamente, todos los componentes suscritos a `clicks` se volverÃ¡n a renderizar :)
Isn't it amazing?

Ahora imagina tener que escribir:

```jsx
const [clicksCount, setClicksCount] = useAtom(clicks)
```

Siempre que quieras usar un Ã¡tomo. Veremos una alternativa en el capÃ­tulo <a href="/features/additional-hooks"> hooks adicionales </a>.
